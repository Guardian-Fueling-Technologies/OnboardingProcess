import unittest
from unittest.mock import patch, MagicMock
import json
import datetime
import pandas as pd
from decimal import Decimal

# Correctly import from your main Flask application file
# Assuming your main Flask app and DB functions are in 'servertest.py'
from app import app
from servertest import insert_onboard_request, sanitize_input, get_db_connection # Make sure get_db_connection is imported to be patched


class FlaskAPITests(unittest.TestCase):

    def setUp(self):
        """Set up for test execution."""
        self.app = app.test_client()
        self.app.testing = True

    # --- Test add_submission (POST) ---
    @patch('servertest.insert_onboard_request') # Patch the DB function called by the route
    def test_add_submission_with_provided_data(self, mock_insert_onboard_request):
        # Configure the mock to return True for success
        mock_insert_onboard_request.return_value = True

        # Your specific data for insertion
        new_submission_data = {
            "Type": "Field-Employee",
            "ProjectedStartDate": "2025-06-23",
            "LegalFirstName": "c",
            "LegalMiddleName": "cc",
            "LegalLastName": "c",
            "Suffix": "c",
            "PositionTitle": "c",
            "Manager": "c",
            "Department": "Parts",
            "Location": "GuardianConnect",
            "PayRateType": "Salary",
            "PayRate": 22,
            "AdditionType": "New Role",
            "IsReHire": False,
            "IsDriver": False,
            "EmployeeID_Requested": True,
            "PurchasingCard_Requested": False,
            "GasCard_Requested": True,
            "EmailAddress_Provided": "test@example.com", # <--- IMPORTANT: Change False to a string email
            "MobilePhone_Requested": False,
            "TLCBonusEligible": False,
            "NoteField": "dd\nEmployee ID: dd\nGas Card: dd",
            "Createdby": "Frontend_User",
            # "CreatedAt": "2025-06-23 15:26:35.1080000" # Remove CreatedAt, it's generated by backend
        }

        print("\n--- Running test_add_submission_with_provided_data ---")
        print(f"Data sent to Flask route: {json.dumps(new_submission_data, indent=2)}")

        response = self.app.post(
            '/api/submissions',
            data=json.dumps(new_submission_data),
            content_type='application/json'
        )

        print(f"Flask route response status code: {response.status_code}")
        print(f"Flask route response data: {json.loads(response.data)}")

        # Assertions
        self.assertEqual(response.status_code, 201)
        self.assertEqual(json.loads(response.data)['message'], "Submission added successfully")
        mock_insert_onboard_request.assert_called_once() # Verify that insert_onboard_request was called

        # You can inspect the arguments passed to the mock if needed
        args, kwargs = mock_insert_onboard_request.call_args
        self.assertIsInstance(args[0], dict)
        # Check specific values passed to insert_onboard_request
        self.assertEqual(args[0]['LegalFirstName'], "c")
        self.assertEqual(args[0]['PayRate'], 22)
        # Verify that 'EmailAddress_Provided' is a string now
        self.assertEqual(args[0]['EmailAddress_Provided'], "test@example.com")
        self.assertIn('CreatedAt', args[0]) # Should be added by the route/insert_onboard_request

# You can uncomment this line to only run tests in the FlaskAPITests class
# if __name__ == '__main__':
#     unittest.main()

# To run ONLY this specific test, you can use a custom test suite or specify it in the command line
# For now, let's keep the main for simple execution and focus on this test.